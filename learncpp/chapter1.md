# Chapter 1
All stories have beginnings. Every great master begins as a student who had a desire to seek out a great teacher to learn from. Our teacher will be Ira Pohl's book, *C++ by Dissection*. Why this book? Well, when I was an undergraduate attending school, I found it amongst a pile of books the computer science department was discarding. So it seems like as good a book as any to go with. I'll get to satisfy my lust for adventure by cracking into it and seeing what it has to offer. And if you're worried that you won't be able to follow along because you don't own this book, don't fear, I'll be making every page of it available here. Perhaps it's illegal, but I'd much rather take the risk of offending the authorities then prevent any potential readers from accessing the very same information that I'm using to come to my conclusions about computer programming.

## Page 1
![page 1 chapter 1](/assets/cppbd/c1p1.jpg)

We are going to take note a few things that are said here in this first page.
> The basic ideas presented here become the foundation for more complete explanations that occur in later chapters.

Here the author is gently letting us know that we should **PAY ATTENTION** to what's being said here so we don't screw ourselves later. We may not program anything exciting within the first chapter but that doesn't mean the material here is any less relevant than what comes ahead.

> Throughout this chapter and the throughout the text, many examples are given. Included are many complete programs, which are often dissected. This allows the reader to see in detail how each construct works.

There's going to be lots of examples and lots of breakdowns of them. *If* we take the time and effort to understand these 'dissections', we'll gain a good understanding of the things we're being taught.

> C++ is largely a superset of C. By learning C++, you are also learning the kernel language C.

C++ has everything the other computer programming language called C has plus a bunch of extra shit. If we learn C++ well we'll be able to handle programming in C (in theory).

## Page 2
![page 2 chapter 1](/assets/cppbd/c1p2.jpg)
> A companion book, *C by Dissection: Fourth Edition*, by Al Kelley and Ira Pohl (Addison-Wesley, 2000), teachers the rest of C that is not found.
>
> Most chapters also have a comparison between C++ and Java programs. Java is partly based on C++. However, unlike C++, some C concepts do not work in Java or have a different meaning. Increasingly, people who begin to Program in C++ have started from a Java background. An introduction to the Java programming process can be found in the companion volume *Java by Dissection*, by Ira Pohl and Charlie McDowell (Addison-Wesley, 1999). The modern programmer needs to be comfortable in all three C-based languages.

Ah yes the "learn more here!" sales tactic. There are parts of the C language that won't be covered here in this book we are referencing. There's also Java code in this book too, and I guess the point of that is to ease the transition from Java to C++ for developers with a background in Java. I fit into this category of people so that may prove useful. The author wants you to go buy other books that he's written to get the scoop on all that. We'll be fine without, thanks. Take another careful look at this assertion:
> The modern programmer needs to be comfortable in all three C-based languages.

Student: Three programming languages! You mean to tell me I've got to go run off and learn two more computer languages after learning this one too. My god, when does it end!

Teacher: In a professional setting you are likely going to need knowledge of **MORE** than just three languages. The technology that I use in my current position relies on these languages:
- Javascript
- C#
- PL/pgSQL
- SQL
- Windows PowerShell
- Groovy

Chances are good I'm forgetting something but the point is that bigger systems that operate in a business environment tend to be composed of many pieces of technology that can be leveraged with different languages. It seems a little crazy that there are that many languages you have to get familiar with but many of these languages share similar features. You also probably won't need to be an expert in all of them to complete feature work for your product since a passing familiarity with each is likely all that's needed. If we get good at understanding computing and problem solving concepts in C++ we'll be able to transition to many other languages without too much more effort, although the devil is still in the details, as they say.
